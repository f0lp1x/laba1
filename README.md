# laba1
1. Пример: Запуск потоков с задержкой

import random
import time
from threading import Thread

class MyThread(Thread):

    def __init__(self, name):
        # Инициализация потока с указанием имени
        Thread.__init__(self)  # Инициализация базового класса
        self.name = name

    def run(self):
        # Метод, который выполняется при запуске потока
        amount = random.randint(3, 15)  # Генерация случайной задержки
        time.sleep(amount)  # Приостановка потока на случайное количество секунд
        msg = f"{self.name} is running"  # Формирование сообщения
        print(msg)  # Вывод сообщения
        

def create_threads():
    # Функция для создания и запуска 5 потоков
    for i in range(5):
        name = f"Thread #{i + 1}"  # Присваиваем имя каждому потоку
        my_thread = MyThread(name)  # Создаем новый поток
        my_thread.start()  # Запускаем поток

create_threads()  # Запускаем функцию для создания и запуска потоков

Описание:

 • Thread: Используется для создания и управления потоками.
 • MyThread: Класс, который наследует Thread и переопределяет метод run, что позволяет каждому потоку выполнять код с задержкой.
 • create_threads: Создает и запускает 5 потоков, каждый из которых ждет случайное количество времени перед выводом сообщения.
 • Инициализация потоков: Для каждого потока генерируется уникальное имя и поток запускается с помощью метода start(), который вызывает метод run.

2. Пример: Многопоточность для вычисления квадратов чисел

import threading
import time

# Функция для вычисления квадратов чисел
def calculate_square(number):
    print(f"Calculating square of {number}")
    time.sleep(1)  # Имитация задержки в вычислениях
    square = number * number  # Вычисление квадрата числа
    print(f"The square of {number} is {square}")

# Функция для создания и запуска потоков
def create_threads(numbers):
    threads = []  # Список для хранения потоков
    for number in numbers:
        thread = threading.Thread(target=calculate_square, args=(number,))
        threads.append(thread)  # Добавляем поток в список
        thread.start()  # Запускаем поток

    # Ожидание завершения всех потоков
    for thread in threads:
        thread.join()  # Ждем, пока поток завершится

# Главная часть программы
numbers_to_calculate = [1, 2, 3, 4, 5]  # Числа для вычисления квадратов
create_threads(numbers_to_calculate)  # Создаем и запускаем потоки

Описание:

 • calculate_square: Функция, которая принимает число, делает паузу на 1 секунду и вычисляет его квадрат.
 • create_threads: Создает и запускает потоки для каждого числа в списке. Каждый поток выполняет функцию calculate_square.
 • join(): Позволяет программе дождаться завершения всех потоков перед продолжением работы программы.

Основные моменты:

 1. Оба примера используют многопоточность для выполнения задач параллельно, но для разных целей:
 • В первом примере каждый поток выполняется с задержкой перед выводом сообщения.
 • Во втором примере потоки вычисляют квадраты чисел.
 2. Использование метода start() для запуска потоков и метода join() для ожидания их завершения гарантирует, что все потоки будут корректно выполнены.

Оба примера демонстрируют, как легко использовать многопоточность в Python для параллельного выполнения задач, что может быть полезно для улучшения производительности программы.
